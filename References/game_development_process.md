

## Chapter: The Game Development Flow

The process of creating a computer game can be viewed as a sequence of stages that integrate both artistic and technical efforts. While game design is primarily an artistic endeavor, requiring the designer to pursue grand artistic goals, it also necessitates technical mastery of the chosen medium, which, in this context, is the computer. The procedure outlined here is based on the author's experience and is presented as a suggested approach rather than a rigid, formal methodology. Game design is too complex an activity to be reduced to a strict procedure, and a designer's personality should influence their working habits.

The suggested sequence for designing and programming a computer game is as follows:

1.  **Choose a Goal and a Topic**
    This initial step is vitally important, though sometimes overlooked. It begins with deciding what kind of game to create. The most satisfying games to design often stem from a topic or genre that the designer is deeply interested in. The selection of a goal is a subjective process, requiring the designer to choose something they believe in, something that expresses their aesthetic sense and worldview. **Honesty to oneself in goal selection is essential**; attempting to satisfy the audience without aligning with one's own taste will likely result in an "anemic game". While marketplace realities might sometimes necessitate designing games that are not direct expressions of the designer's deepest interests, such games may lack the psychological impact of those "coming straight from the heart".

    The **topic** is the means by which the goal is expressed â€“ the environment, conditions, and events that communicate the abstract goal. For example, the goal might be to explore the nature of leadership, and the topic could be the Arthurian legends. It's a significant mistake to prioritize the topic over the goal. The topic must be carefully examined for its ability to successfully realize the game's goals, as some topics carry emotional baggage that could interfere.

2.  **Research and Preparation**
    Once the goal and topic are firm, the designer should immerse themselves in the topic. This involves reading everything available on the subject and studying previous related efforts. Understanding the mechanics and environment the game will represent is crucial to providing an "authentic feel". During this phase, it's critical **not to commit much to paper and, above all, write no code**. This is a time for contemplation, meditation, and weaving together the goal, topic, and research findings. Specific implementation ideas will arise but should be considered candidates, not requirements, and must be ruthlessly winnowed later. Impatience in this phase can lead to game-killing mistakes.

3.  **Design Phase**
    This phase is where the concrete form of the game begins to take shape. The primary goal is to create the outlines of three interdependent structures:
    *   **I/O Structure**: This is the system for communicating information between the computer and the player. It dictates what is possible within the game. The I/O is composed of output (primarily graphics and sound) and input (keyboard, joystick, paddle, mouse). Graphics and sound should be primarily **functional and informative**, used to convey critical game information and support the fantasy, not merely to show off graphical abilities. The input structure is the player's "tactile contact" with the game and should be designed to be rewarding, not frustrating. A fundamental dilemma is balancing the richness of player options (required for expressing personality) with a clean, non-intimidating input structure. Designers should ideally minimize reliance on the keyboard for input and focus on simple, single devices. **Designing around the I/O** is presented as a key precept, as the limitations of input/output often dominate game implementation.
    *   **Game Structure**: This is the internal architecture of causal relationships and rules that define the obstacles and interactions within the game. The designer must identify a **key element** from the topic environment that is central, representative, manipulable, and understandable, and build the game around it. This key element must be expressively, concisely, meaningfully, and focusedly manipulable. The designer has more latitude with the internal structure than the I/O structure, as the player doesn't directly encounter its complexities. It's important to add enough detail ("color") to convey an authentic feel, but to maintain a sense of proportion and avoid piling on too many features, which can lead to a "dirty" and overly intricate game.
    *   **Program Structure**: This is the plan for the underlying code organization, including memory allocation, definitions of variables and subroutines, and documentation of program flow. This structure translates the I/O and game structures into a real product.
    These three structures must be designed simultaneously and work in concert. Decisions in one area must be checked for their impact on the others.

    *   **Evaluation of the Design**: Before moving forward, the overall design is evaluated for common flaws. Key questions include whether the design satisfies the initial goals and ensures the desired player experience. The stability of the game structure is checked to prevent situations where game values get out of control. The design is also probed for unanticipated shortcuts that allow players to win with minimal effort. The most crucial decision at this stage is whether to **abort the game**; if it no longer excites the designer or there are significant doubts, it is better to stop now than later, when more effort has been invested.

4.  **Pre-programming Phase**
    If the design is approved, the ideas are formally committed to paper. This involves preparing complete game documentation that defines the I/O structure and internal game structure, focusing on the player's experience rather than technical details. Program structure notes are adjusted as needed.

5.  **Programming Phase**
    This is described as the easiest phase, primarily involving straightforward and tedious implementation work requiring attention to detail. The author suggests that effort, rather than talent, is usually the crucial factor in programming a game, implying that technical programming skill is less likely to be the sole cause of failure compared to lack of effort.

6.  **Playtesting Phase**
    Playtesting is ideally used to refine and polish the game design, but in practice, it often reveals fundamental design or programming problems. Playtesting can uncover both nonfatal, correctable flaws (insufficiency or excess) and fatal flaws (fundamental incompatibilities). **Trash a game with a fatal flaw**; patching after programming is complete offers only limited gains. If serious but nonfatal problems are found, the designer must analyze the root cause, devise multiple solutions, and choose the one that best meets the game's goals, not just the easiest one. Playtesting involves the designer's own testing during debugging and later testing by other players. It is important not to show playtesters an incomplete game, as this can contaminate their objectivity. Playtesters should ideally be familiar with games and able to analyze and criticize from experience. Market research methods involving large numbers of inexperienced players are viewed skeptically for creating great art, though they may be useful for mass-market games. Playtesters should be given a preliminary manual and allowed to experience the game without coaching. Playtesters' criticisms must be evaluated carefully, and the designer should be prepared to reject suggestions incompatible with goals, unachievable, or requiring disproportionate effort. The final stage involves **polishing** the game, which is critical but often occurs when the designer is tired of the project. This involves fine-tuning, adding small embellishments, and rigorous testing. The preparation of a game manual is also a vital task, helping to overcome computer limitations, provide static information, support the fantasy, and clarify misunderstandings. The designer should write their own manual first, even if a professional writer is hired, as it provides valuable feedback on the design's cleanliness.

7.  **Post-mortem**
    After release, the game faces critics, whose reviews may not always be accurate or insightful. The designer should pay attention to thoughtful criticism from reputable sources but otherwise focus on whether they met their own goals. Consistent negative feedback might prompt a reconsideration of artistic values.

This suggested process, while not a rigid formula, provides a framework for navigating the complexities of bringing a computer game concept to life, emphasizing the interconnectedness of design, technology, and the player experience. The experience of developing a game like EXCALIBUR illustrates that the real process can be "jerky and mistake-prone," contrasting with this idealized sequence.

***
