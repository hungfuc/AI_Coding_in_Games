
# Chapter 10: Creating a 3D Three.js Game from Story to Code Using Vibe Coding — Full Case Study


**Learning Objectives**

By the end of this chapter, you will be able to:

1. Develop a compelling 3D game story suitable for a Three.js game.
2. Convert the story into a structured Game Design Document (GDD).
3. Craft step-by-step vibe coding prompts to generate game features with AI.
4. Understand key Three.js coding techniques via example code.
5. Apply debugging and testing best practices to the AI-assisted game project.


## 10.1 Game Story — Orbital Escape

### 10.1.1 Narrative Summary

> **"Orbital Escape"** is a 3D space adventure game where the player pilots a small spaceship trapped in a hazardous asteroid belt orbiting a distant planet. The goal is to navigate the ship through moving asteroids and collect energy orbs while avoiding collisions. Collecting enough orbs unlocks the escape jump to the next level.


### 10.1.2 Player Experience

* Thrilling navigation challenge in a dynamic 3D environment.
* Precise control of a spaceship (forward, backward, left, right, and slight up/down).
* Visual and audio feedback on collecting orbs and hitting obstacles.
* Increasing difficulty with faster asteroids and tighter gaps.


## 10.2 Game Design Document (GDD)


| Section               | Details                                                                      |
| --------------------- | ---------------------------------------------------------------------------- |
| **Genre**             | 3D Space Navigation / Avoidance                                              |
| **Platform**          | Web Browser (Three.js / JavaScript)                                          |
| **Player Controls**   | WASD for horizontal movement, QE for vertical control                        |
| **Game Objects**      | Spaceship (player), moving asteroids (obstacles), energy orbs (collectibles) |
| **Objectives**        | Collect 10 energy orbs to unlock escape, avoid asteroid collisions           |
| **Scoring**           | +10 points per orb collected                                                 |
| **Level Progression** | Increasing asteroid speed and quantity per level                             |
| **Visual Style**      | Stylized low-poly 3D models, neon glowing orbs, starfield background         |
| **UI Elements**       | Score display, energy orb counter, game over and level complete screens      |



## 10.3 From GDD to Vibe Coding Prompts


To develop "Orbital Escape," we break down the GDD into manageable features and generate precise vibe coding prompts for each.



#### Feature Breakdown & Prompt Examples

| Feature                        | Vibe Coding Prompt Example                                                                                                                         |
| ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| Scene Setup                    | "Generate Three.js code to create a scene with a perspective camera, ambient light, directional light, and starfield background."                  |
| Player Spaceship               | "Generate a low-poly spaceship mesh controllable with WASD for horizontal movement and QE for vertical movement."                                  |
| Asteroids                      | "Generate multiple moving asteroid meshes that float through space with random trajectories and respawn."                                          |
| Energy Orbs                    | "Generate glowing energy orb meshes positioned randomly in the scene that the player can collect."                                                 |
| Collision Detection            | "Generate code to detect collisions between the spaceship and asteroids (game over), and between spaceship and orbs (collect and increase score)." |
| UI Elements                    | "Generate HTML/CSS and JavaScript code for displaying score, orb count, and game status messages."                                                 |
| Level Progression & Difficulty | "Generate code to increase asteroid speed and spawn rate as the player collects more orbs."                                                        |

---

## 10.4 Detailed Coding Examples & Explanations


### 10.4.1 Scene Setup with Starfield Background

**Prompt:**

> Generate Three.js code to create a scene with a perspective camera, ambient and directional lighting, and a simple starfield background.

**Code Explanation:**

* Initialize the scene and camera with standard perspective.
* Add ambient and directional lights for soft and directional illumination.
* Create a starfield using small white points randomly distributed in 3D space.

```javascript
import * as THREE from 'three';

// Scene and camera
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  75, window.innerWidth / window.innerHeight, 0.1, 1000
);
camera.position.z = 30;

// Renderer
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lighting
const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // Soft light
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(10, 10, 10);
scene.add(directionalLight);

// Starfield background
const starsGeometry = new THREE.BufferGeometry();
const starCount = 500;
const starVertices = [];
for (let i = 0; i < starCount; i++) {
  starVertices.push(
    (Math.random() - 0.5) * 200,
    (Math.random() - 0.5) * 200,
    (Math.random() - 0.5) * 200
  );
}
starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));

const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff });
const starField = new THREE.Points(starsGeometry, starsMaterial);
scene.add(starField);

// Resize handler
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
```


### 10.4.2 Player Spaceship with Controls

**Prompt:**

> "Generate code to create a simple spaceship mesh and implement WASD + QE controls for movement in 3D space."

**Explanation:**

* Create a low-poly spaceship from basic geometries (cone + cylinder).
* Track keyboard inputs to move ship left/right/forward/back and up/down.
* Limit movement boundaries for gameplay balance.

```javascript
// Spaceship Group
const ship = new THREE.Group();

// Cone as ship nose
const coneGeometry = new THREE.ConeGeometry(1, 3, 8);
const coneMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
const cone = new THREE.Mesh(coneGeometry, coneMaterial);
cone.rotation.x = Math.PI / 2;
ship.add(cone);

// Cylinder as ship body
const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 3, 8);
const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x007700 });
const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
body.position.y = -1.5;
ship.add(body);

scene.add(ship);

// Ship movement parameters
const shipSpeed = 0.3;
const shipBounds = { x: 15, y: 10, z: 20 };

const keysPressed = {};
window.addEventListener('keydown', (e) => { keysPressed[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', (e) => { keysPressed[e.key.toLowerCase()] = false; });

function updateShip() {
  if (keysPressed['w']) ship.position.z -= shipSpeed;
  if (keysPressed['s']) ship.position.z += shipSpeed;
  if (keysPressed['a']) ship.position.x -= shipSpeed;
  if (keysPressed['d']) ship.position.x += shipSpeed;
  if (keysPressed['q']) ship.position.y += shipSpeed;
  if (keysPressed['e']) ship.position.y -= shipSpeed;

  // Clamp position within bounds
  ship.position.x = THREE.MathUtils.clamp(ship.position.x, -shipBounds.x, shipBounds.x);
  ship.position.y = THREE.MathUtils.clamp(ship.position.y, -shipBounds.y, shipBounds.y);
  ship.position.z = THREE.MathUtils.clamp(ship.position.z, -shipBounds.z, shipBounds.z);
}
```


### 10.4.3 Asteroids: Moving Obstacles

**Prompt:**

> Generate multiple asteroid meshes (spheres with noise) that move across the scene on random paths and respawn after leaving view.

**Explanation:**

* Use spheres with irregular material to simulate asteroids.
* Assign each asteroid a velocity vector for movement.
* Respawn them randomly behind the player once they pass out of view.

```javascript
const asteroidCount = 20;
const asteroids = [];

function createAsteroid() {
  const geometry = new THREE.IcosahedronGeometry(1, 1);
  const material = new THREE.MeshStandardMaterial({ color: 0x666666, flatShading: true });
  const asteroid = new THREE.Mesh(geometry, material);
  asteroid.position.set(
    (Math.random() - 0.5) * 40,
    (Math.random() - 0.5) * 20,
    -50 - Math.random() * 100
  );
  asteroid.userData.velocity = new THREE.Vector3(
    (Math.random() - 0.5) * 0.1,
    (Math.random() - 0.5) * 0.05,
    0.2 + Math.random() * 0.3
  );
  scene.add(asteroid);
  return asteroid;
}

for (let i = 0; i < asteroidCount; i++) {
  asteroids.push(createAsteroid());
}

function updateAsteroids() {
  asteroids.forEach(ast => {
    ast.position.add(ast.userData.velocity);

    if (ast.position.z > 30) { // beyond player camera
      ast.position.set(
        (Math.random() - 0.5) * 40,
        (Math.random() - 0.5) * 20,
        -100 - Math.random() * 50
      );
    }
  });
}
```


### 10.4.4 Energy Orbs: Collectibles

**Prompt:**

> "Generate glowing orbs scattered in space that rotate slowly and can be collected by the player."

**Explanation:**

* Create small spheres with emissive materials for glow.
* Place randomly ahead of the player.
* Rotate them each frame for visual effect.

```javascript
const orbCount = 10;
const orbs = [];

function createOrb() {
  const geometry = new THREE.SphereGeometry(0.5, 16, 16);
  const material = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1 });
  const orb = new THREE.Mesh(geometry, material);
  orb.position.set(
    (Math.random() - 0.5) * 30,
    (Math.random() - 0.5) * 15,
    -20 - Math.random() * 60
  );
  scene.add(orb);
  return orb;
}

for (let i = 0; i < orbCount; i++) {
  orbs.push(createOrb());
}

function updateOrbs() {
  orbs.forEach(orb => {
    orb.rotation.y += 0.02;
  });
}
```


### 10.4.5 Collision Detection & Scoring

**Prompt:**

> Generate code to detect collisions between spaceship and asteroids (trigger game over), and spaceship and orbs (collect orb, increase score, and respawn orb).

**Explanation:**

* Use bounding spheres for simple collision checks.
* On asteroid collision, stop the game loop and show game over UI.
* On orb collision, increment score, reposition orb.

```javascript
let score = 0;
let gameOver = false;

// Helper function for sphere collision
function sphereCollision(pos1, radius1, pos2, radius2) {
  return pos1.distanceTo(pos2) < radius1 + radius2;
}

function checkCollisions() {
  // Spaceship bounding sphere approx radius
  const shipPos = ship.position;
  const shipRadius = 2;

  // Asteroid collisions
  for (let ast of asteroids) {
    if (sphereCollision(shipPos, shipRadius, ast.position, 1)) {
      gameOver = true;
      showGameOver();
      break;
    }
  }

  // Orb collisions
  for (let i = orbs.length - 1; i >= 0; i--) {
    const orb = orbs[i];
    if (sphereCollision(shipPos, shipRadius, orb.position, 0.5)) {
      score += 10;
      updateScoreDisplay();

      // Respawn orb ahead
      orb.position.set(
        (Math.random() - 0.5) * 30,
        (Math.random() - 0.5) * 15,
        -20 - Math.random() * 60
      );
    }
  }
}
```


### 10.4.6 UI Elements

**Prompt:**

> Generate HTML and CSS for score display and game over overlay.

```html
<style>
  #score {
    position: fixed;
    top: 10px;
    left: 10px;
    font-family: Arial, sans-serif;
    font-size: 24px;
    color: white;
    text-shadow: 1px 1px 4px black;
    z-index: 10;
  }
  #gameOverOverlay {
    display: none;
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.75);
    color: red;
    font-family: Arial, sans-serif;
    font-size: 48px;
    text-align: center;
    padding-top: 20vh;
    z-index: 20;
  }
  #restartBtn {
    margin-top: 20px;
    font-size: 24px;
    cursor: pointer;
  }
</style>
<div id="score">Score: 0</div>
<div id="gameOverOverlay">
  Game Over!<br />
  <button id="restartBtn">Restart</button>
</div>
```

**JS code snippet:**

```javascript
const scoreEl = document.getElementById('score');
const gameOverOverlay = document.getElementById('gameOverOverlay');
const restartBtn = document.getElementById('restartBtn');

function updateScoreDisplay() {
  scoreEl.textContent = `Score: ${score}`;
}

function showGameOver() {
  gameOverOverlay.style.display = 'block';
}

function hideGameOver() {
  gameOverOverlay.style.display = 'none';
}

restartBtn.addEventListener('click', () => {
  resetGame();
});
```


### 10.4.7 Game Loop & Integration

```javascript
function animate() {
  if (!gameOver) {
    requestAnimationFrame(animate);
  }
  updateShip();
  updateAsteroids();
  updateOrbs();
  checkCollisions();
  renderer.render(scene, camera);
}

function resetGame() {
  score = 0;
  updateScoreDisplay();
  gameOver = false;
  hideGameOver();

  // Reset positions
  ship.position.set(0, 0, 20);
  asteroids.forEach(ast => {
    ast.position.set(
      (Math.random() - 0.5) * 40,
      (Math.random() - 0.5) * 20,
      -50 - Math.random() * 100
    );
  });
  orbs.forEach(orb => {
    orb.position.set(
      (Math.random() - 0.5) * 30,
      (Math.random() - 0.5) * 15,
      -20 - Math.random() * 60
    );
  });

  animate();
}

// Start the game
resetGame();
```


## 10.5 Debugging and Testing AI-Generated Code

* **Use Browser DevTools** to inspect console logs and errors.
* **Add debugging logs:** For example, log ship position and collisions.
* **Test Controls and Boundaries:** Ensure smooth ship movement and clamping.
* **Test Collision Responses:** Verify that orbs disappear/reappear and game over triggers correctly.
* **Use small incremental prompt generations:** Build each feature stepwise to isolate bugs.



## 10.6 Game Improvement — Making Orbital Escape More Fun and Accessible


#### Problem Summary

After initial testing, the game “Orbital Escape” has some issues.

* Energy orbs are too spread out and hard to reach.
* Asteroids are too fast and densely packed near the player.
* Player movement speed feels slow for dodging obstacles and collecting orbs.
* No feedback or effects to enhance orb collection experience.


#### Goal for Improvement

* Make orbs easier and more satisfying to collect.
* Balance asteroid speed and quantity to allow skillful play without frustration.
* Add visual and audio feedback on orb collection.
* Increase player movement speed slightly.
* Add a simple progression system where difficulty ramps up gradually.


### 10.6.1 Use Vibe Coding to Improve the Game

We will craft targeted prompts to generate improved code snippets and features step-by-step.


#### Example Prompts for Improvement

**Goal 1:** 
Make energy orbs spawn closer to the player and cluster slightly so they’re easier to reach.
**Prompt:**
> Generate Three.js code to spawn energy orbs in small clusters near the player’s current position instead of random distant placement. Ensure orbs are within 15 units of the ship and spread in small groups of 3-5.



**Goal 2:** 
Adjust asteroid speed and quantity dynamically based on player score for gradual difficulty increase.

**Prompt:**
> “Generate JavaScript code to increase asteroid movement speed and spawn rate proportionally to player’s score, starting slow and gradually getting faster and more frequent.”


**Goal 3:** 
Increase player movement speed by 50% for more responsive controls.

**Prompt:**
> Generate code to increase player ship movement speed from 0.3 to 0.45 units per frame in all directions.


**Goal 4:** 
Add a glowing particle effect and a short sound when the player collects an energy orb.

**Prompt:**
> Generate Three.js particle effect code to trigger a glowing burst around an orb when collected and play a short ‘collect’ sound.



**Goal 5:** 
Display a progress bar UI element showing orbs collected out of 10 to unlock the next level.

**Prompt:**
> Generate HTML/CSS/JavaScript code for a progress bar at the top of the screen that fills as player collects energy orbs, from 0 to 10, to indicate progress toward level completion.



#### Applying the Improvements — Sample Generated Code Snippets


**1. Clustered Orb Spawn Example:**

```javascript
function spawnOrbCluster(centerPos, count = 4) {
  for (let i = 0; i < count; i++) {
    const offset = new THREE.Vector3(
      (Math.random() - 0.5) * 5,
      (Math.random() - 0.5) * 5,
      (Math.random() - 0.5) * 5
    );
    const orb = createOrb();
    orb.position.copy(centerPos).add(offset);
    orbs.push(orb);
    scene.add(orb);
  }
}

// On reset or when respawning orbs near player:
orbs.forEach(orb => scene.remove(orb));
orbs.length = 0;

const shipPos = ship.position.clone();
spawnOrbCluster(shipPos, 5);
```


**2. Dynamic Asteroid Speed & Spawn Rate:**

```javascript
function updateAsteroids() {
  const speedMultiplier = 1 + score / 100; // Speed increases with score

  asteroids.forEach(ast => {
    ast.position.addScaledVector(ast.userData.velocity, speedMultiplier);

    if (ast.position.z > 30) {
      ast.position.set(
        (Math.random() - 0.5) * 40,
        (Math.random() - 0.5) * 20,
        -100 - Math.random() * 50
      );
      // Increase velocity magnitude with score
      ast.userData.velocity.multiplyScalar(speedMultiplier);
    }
  });
}
```


**3. Increased Ship Speed:**

```javascript
const shipSpeed = 0.45; // Increased from 0.3

// Movement logic remains the same but benefits from higher speed
```


**4. Orb Collection Effects (Particles + Sound):**

```javascript
// Simplified glowing effect on orb collection
function playOrbCollectEffect(orb) {
  const glowGeometry = new THREE.SphereGeometry(orb.scale.x * 2, 16, 16);
  const glowMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.7 });
  const glow = new THREE.Mesh(glowGeometry, glowMaterial);
  glow.position.copy(orb.position);
  scene.add(glow);

  setTimeout(() => scene.remove(glow), 300);

  // Play sound
  const audio = new Audio('https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg');
  audio.play();
}

// In collision check:
if (sphereCollision(shipPos, shipRadius, orb.position, 0.5)) {
  score += 10;
  updateScoreDisplay();
  playOrbCollectEffect(orb);

  orb.position.set(
    (Math.random() - 0.5) * 30,
    (Math.random() - 0.5) * 15,
    -20 - Math.random() * 60
  );
}
```


**5. Progress Bar UI:**

```html
<style>
  #progressBarContainer {
    position: fixed;
    top: 50px; left: 10px;
    width: 300px;
    height: 20px;
    background: #555;
    border-radius: 10px;
    overflow: hidden;
    z-index: 15;
  }
  #progressBarFill {
    width: 0%;
    height: 100%;
    background: #0f0;
    transition: width 0.3s ease;
  }
</style>
<div id="progressBarContainer">
  <div id="progressBarFill"></div>
</div>
```

```javascript
const progressBarFill = document.getElementById('progressBarFill');
const orbsToCollect = 10;

function updateProgressBar() {
  const percent = Math.min((score / (orbsToCollect * 10)) * 100, 100);
  progressBarFill.style.width = `${percent}%`;
}

// Update in collision detection after scoring
updateProgressBar();

if (score >= orbsToCollect * 10) {
  alert('Level Complete! You escaped the asteroid field!');
  resetGame();
}
```



Using these prompts and the generated code snippets, you can iteratively:

* Make the orbs easier to find and collect.
* Gradually ramp up challenge instead of sudden difficulty spikes.
* Add satisfying feedback on collecting orbs.
* Improve player control responsiveness.
* Visually track progress to motivate players.



#### What’s Improved in version 2?

Orbs now spawn clustered near the ship’s position, making them easier to collect. Collecting one respawns a full cluster near you.

Asteroids speed and velocity increase gradually with your score to provide ramping challenge.

Player ship speed is increased by 50% for snappier controls.

Collecting an orb triggers a glowing burst effect and a satisfying sound.

A progress bar visually tracks how many orbs you’ve collected toward the level goal (10 orbs).

When the score reaches 100 points (10 orbs × 10 points each), a level complete alert shows and the game resets.



But, the version 2 (generated by above) is still not playable. Therefore the following prompt tries to fix the issues.

**Prompt:**
```
The above game is not playable. The  yellow dot is too big. Also keep popping up windows blocks the game.
```


#### Now the version 3

Got it! Let's fix those issues:

* Make yellow orbs smaller and more visually distinct (smaller radius, less overwhelming).
* Replace the annoying alert popup with an in-game overlay message for "Level Complete" — no blocking alert window.

I'll revise the code to:

* Shrink the orb radius from 0.5 to 0.2.
* Adjust orb geometry and material for a subtle glow but less bulky.
* Replace alert with a smooth overlay message that disappears after a few seconds and then resets.

Here’s the **fixed and playable Orbital Escape** game code with those changes:


```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Orbital Escape - Improved & Playable</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; }

  #score {
    position: fixed;
    top: 10px; left: 10px;
    color: white;
    font-family: Arial, sans-serif;
    font-size: 24px;
    text-shadow: 1px 1px 4px black;
    z-index: 10;
  }

  #gameOverOverlay, #levelCompleteOverlay {
    display: none;
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.75);
    color: white;
    font-family: Arial, sans-serif;
    font-size: 48px;
    text-align: center;
    padding-top: 20vh;
    z-index: 20;
  }
  #gameOverOverlay {
    color: red;
  }

  #restartBtn {
    margin-top: 20px;
    font-size: 24px;
    cursor: pointer;
    padding: 10px 20px;
  }

  #progressBarContainer {
    position: fixed;
    top: 50px; left: 10px;
    width: 300px;
    height: 20px;
    background: #555;
    border-radius: 10px;
    overflow: hidden;
    z-index: 15;
  }
  #progressBarFill {
    width: 0%;
    height: 100%;
    background: #0f0;
    transition: width 0.3s ease;
  }
</style>
</head>
<body>

<div id="score">Score: 0</div>
<div id="progressBarContainer">
  <div id="progressBarFill"></div>
</div>
<div id="gameOverOverlay">
  Game Over!<br />
  <button id="restartBtn">Restart</button>
</div>
<div id="levelCompleteOverlay">
  Level Complete!<br />
  <button id="levelRestartBtn">Play Again</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
(() => {
  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.z = 30;

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lighting
  const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(10, 10, 10);
  scene.add(directionalLight);

  // Starfield
  const starsGeometry = new THREE.BufferGeometry();
  const starCount = 500;
  const starVertices = [];
  for (let i = 0; i < starCount; i++) {
    starVertices.push(
      (Math.random() - 0.5) * 200,
      (Math.random() - 0.5) * 200,
      (Math.random() - 0.5) * 200
    );
  }
  starsGeometry.setAttribute(
    'position',
    new THREE.Float32BufferAttribute(starVertices, 3)
  );
  const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff });
  const starField = new THREE.Points(starsGeometry, starsMaterial);
  scene.add(starField);

  // Player spaceship
  const ship = new THREE.Group();

  const coneGeometry = new THREE.ConeGeometry(1, 3, 8);
  const coneMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
  const cone = new THREE.Mesh(coneGeometry, coneMaterial);
  cone.rotation.x = Math.PI / 2;
  ship.add(cone);

  const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 3, 8);
  const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x007700 });
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  body.position.y = -1.5;
  ship.add(body);

  ship.position.set(0, 0, 20);
  scene.add(ship);

  // Movement controls
  const shipSpeed = 0.45;
  const shipBounds = { x: 15, y: 10, z: 20 };
  const keysPressed = {};

  window.addEventListener('keydown', (e) => {
    keysPressed[e.key.toLowerCase()] = true;
  });
  window.addEventListener('keyup', (e) => {
    keysPressed[e.key.toLowerCase()] = false;
  });

  function updateShip() {
    if (keysPressed['w']) ship.position.z -= shipSpeed;
    if (keysPressed['s']) ship.position.z += shipSpeed;
    if (keysPressed['a']) ship.position.x -= shipSpeed;
    if (keysPressed['d']) ship.position.x += shipSpeed;
    if (keysPressed['q']) ship.position.y += shipSpeed;
    if (keysPressed['e']) ship.position.y -= shipSpeed;

    ship.position.x = THREE.MathUtils.clamp(ship.position.x, -shipBounds.x, shipBounds.x);
    ship.position.y = THREE.MathUtils.clamp(ship.position.y, -shipBounds.y, shipBounds.y);
    ship.position.z = THREE.MathUtils.clamp(ship.position.z, -shipBounds.z, shipBounds.z);
  }

  // Asteroids
  let asteroidCount = 20;
  const asteroids = [];

  function createAsteroid() {
    const geometry = new THREE.IcosahedronGeometry(1, 1);
    const material = new THREE.MeshStandardMaterial({ color: 0x666666, flatShading: true });
    const asteroid = new THREE.Mesh(geometry, material);
    asteroid.position.set(
      (Math.random() - 0.5) * 40,
      (Math.random() - 0.5) * 20,
      -50 - Math.random() * 100
    );
    asteroid.userData.velocity = new THREE.Vector3(
      (Math.random() - 0.5) * 0.1,
      (Math.random() - 0.5) * 0.05,
      0.2 + Math.random() * 0.3
    );
    scene.add(asteroid);
    return asteroid;
  }

  function spawnAsteroids() {
    asteroids.forEach(ast => scene.remove(ast));
    asteroids.length = 0;
    for (let i = 0; i < asteroidCount; i++) {
      asteroids.push(createAsteroid());
    }
  }

  // Energy orbs (smaller radius now)
  const orbs = [];
  const orbsToCollect = 10;

  function createOrb() {
    const geometry = new THREE.SphereGeometry(0.2, 16, 16);
    const material = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1 });
    const orb = new THREE.Mesh(geometry, material);
    return orb;
  }

  function spawnOrbCluster(centerPos, count = 5) {
    orbs.forEach(orb => scene.remove(orb));
    orbs.length = 0;

    for (let i = 0; i < count; i++) {
      const offset = new THREE.Vector3(
        (Math.random() - 0.5) * 5,
        (Math.random() - 0.5) * 5,
        (Math.random() - 0.5) * 5
      );
      const orb = createOrb();
      orb.position.copy(centerPos).add(offset);
      orbs.push(orb);
      scene.add(orb);
    }
  }

  // Collision detection helper
  function sphereCollision(pos1, radius1, pos2, radius2) {
    return pos1.distanceTo(pos2) < radius1 + radius2;
  }

  // Orb collection effect
  function playOrbCollectEffect(orb) {
    const glowGeometry = new THREE.SphereGeometry(orb.scale.x * 3, 16, 16);
    const glowMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.7 });
    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
    glow.position.copy(orb.position);
    scene.add(glow);

    setTimeout(() => scene.remove(glow), 300);

    const audio = new Audio('https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg');
    audio.play();
  }

  // Game state
  let score = 0;
  let gameOver = false;

  // UI
  const scoreEl = document.getElementById('score');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const levelCompleteOverlay = document.getElementById('levelCompleteOverlay');
  const restartBtn = document.getElementById('restartBtn');
  const levelRestartBtn = document.getElementById('levelRestartBtn');
  const progressBarFill = document.getElementById('progressBarFill');

  function updateScoreDisplay() {
    scoreEl.textContent = `Score: ${score}`;
  }

  function updateProgressBar() {
    const percent = Math.min((score / (orbsToCollect * 10)) * 100, 100);
    progressBarFill.style.width = `${percent}%`;
  }

  function showGameOver() {
    gameOverOverlay.style.display = 'block';
  }

  function hideGameOver() {
    gameOverOverlay.style.display = 'none';
  }

  function showLevelComplete() {
    levelCompleteOverlay.style.display = 'block';
  }

  function hideLevelComplete() {
    levelCompleteOverlay.style.display = 'none';
  }

  // Asteroid update with speed scaling
  function updateAsteroids() {
    const speedMultiplier = 1 + score / 100;

    asteroids.forEach(ast => {
      ast.position.addScaledVector(ast.userData.velocity, speedMultiplier);

      if (ast.position.z > 30) {
        ast.position.set(
          (Math.random() - 0.5) * 40,
          (Math.random() - 0.5) * 20,
          -100 - Math.random() * 50
        );
        ast.userData.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.1 * speedMultiplier,
          (Math.random() - 0.5) * 0.05 * speedMultiplier,
          (0.2 + Math.random() * 0.3) * speedMultiplier
        );
      }
    });
  }

  // Orbs rotate for visibility
  function updateOrbs() {
    orbs.forEach(orb => {
      orb.rotation.y += 0.02;
    });
  }

  // Check collisions
  function checkCollisions() {
    const shipPos = ship.position;
    const shipRadius = 2;

    for (let ast of asteroids) {
      if (sphereCollision(shipPos, shipRadius, ast.position, 1)) {
        gameOver = true;
        showGameOver();
        break;
      }
    }

    if (gameOver) return;

    for (let orb of orbs) {
      if (sphereCollision(shipPos, shipRadius, orb.position, 0.2)) {
        score += 10;
        updateScoreDisplay();
        updateProgressBar();
        playOrbCollectEffect(orb);

        spawnOrbCluster(ship.position, orbsToCollect);
        break;
      }
    }

    if (score >= orbsToCollect * 10) {
      showLevelComplete();
      gameOver = true; // pause game loop

      setTimeout(() => {
        hideLevelComplete();
        resetGame();
      }, 3500);
    }
  }

  // Restart handlers
  restartBtn.addEventListener('click', () => {
    resetGame();
  });

  levelRestartBtn.addEventListener('click', () => {
    hideLevelComplete();
    resetGame();
  });

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  function animate() {
    if (!gameOver) {
      requestAnimationFrame(animate);
    }
    updateShip();
    updateAsteroids();
    updateOrbs();
    checkCollisions();
    renderer.render(scene, camera);
  }

  function resetGame() {
    score = 0;
    updateScoreDisplay();
    updateProgressBar();
    gameOver = false;
    hideGameOver();
    hideLevelComplete();

    ship.position.set(0, 0, 20);
    asteroidCount = 20;
    spawnAsteroids();
    spawnOrbCluster(ship.position, orbsToCollect);

    animate();
  }

  resetGame();
})();
</script>

</body>
</html>
```


#### Changes summary:

* Yellow orbs have radius **0.2** instead of 0.5 — smaller, easier to distinguish and collect.
* Removed blocking `alert()` on level complete. Instead:

  * Show a full-screen **“Level Complete!” overlay with a button** to restart.
  * Auto-hide the overlay after 3.5 seconds and reset game automatically.
* Added a **"Play Again" button** on level complete overlay for manual restart.

Try this version — it should be smooth, playable, and less frustrating! If you want, I can help add sound volume controls, polish UI, or extra features next.



#### Version 3's Issues
 - Easy to get level complete
 - The yellow asteroids are still too big.

**prompt:**
```
It is too easy to get level complete. The yellow dot is still too big. need to make it small for the spaceship to catch it.
```


#### Now the version 4

To make the game more challenging and orbs harder to catch, the following will be the changes.

* **Reduce the orb size further from 0.2 to 0.1 radius** (much smaller, more skill needed).
* **Increase the cluster spread so orbs are more spread out**, so player needs to maneuver more.
* **Increase asteroid count a bit for more obstacles.**

Here’s the updated part of the code with these adjustments (full code remains mostly the same, just changing orb size, cluster spread, and asteroid count):

---

#### Changes in orb creation and spawning:

```js
// Orbs radius reduced to 0.1 (smaller)
function createOrb() {
  const geometry = new THREE.SphereGeometry(0.1, 16, 16);
  const material = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1 });
  const orb = new THREE.Mesh(geometry, material);
  return orb;
}

// Spawn orbs with wider spread (8 units instead of 5)
function spawnOrbCluster(centerPos, count = 5) {
  orbs.forEach(orb => scene.remove(orb));
  orbs.length = 0;

  for (let i = 0; i < count; i++) {
    const offset = new THREE.Vector3(
      (Math.random() - 0.5) * 8,  // wider spread
      (Math.random() - 0.5) * 8,
      (Math.random() - 0.5) * 8
    );
    const orb = createOrb();
    orb.position.copy(centerPos).add(offset);
    orbs.push(orb);
    scene.add(orb);
  }
}
```

#### Increase asteroid count in resetGame:

```js
function resetGame() {
  score = 0;
  updateScoreDisplay();
  updateProgressBar();
  gameOver = false;
  hideGameOver();
  hideLevelComplete();

  ship.position.set(0, 0, 20);
  asteroidCount = 30;  // increased from 20 for more challenge
  spawnAsteroids();
  spawnOrbCluster(ship.position, orbsToCollect);

  animate();
}
```

#### Adjust collision radius with orbs to match smaller size:

```js
// In checkCollisions, orb collision radius from 0.2 to 0.1
for (let orb of orbs) {
  if (sphereCollision(shipPos, shipRadius, orb.position, 0.1)) {
    // ...
  }
}
```

---

#### Version 5: 

We try to use arrow keys for moving left, right, up, down. and A and Z for moving forward and backward. The following is the prompt.

```
Change the control by using arrow keys for up down left right and use the A for moving forward and Z for moving backward.
```
Absolutely! I updated the controls as requested:

* **Arrow keys** — Move **left, right, up, down** (X and Y axes)
* **A** — Move **forward** (decrease Z)
* **Z** — Move **backward** (increase Z)

Here’s the updated control handling and the full bundled game with these changes:


```html
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Orbital Escape - Arrow Key Controls</title>
<style>
  body { margin: 0; overflow: hidden; background: black; }
  canvas { display: block; }

  #score {
    position: fixed;
    top: 10px; left: 10px;
    color: white;
    font-family: Arial, sans-serif;
    font-size: 24px;
    text-shadow: 1px 1px 4px black;
    z-index: 10;
  }

  #gameOverOverlay, #levelCompleteOverlay {
    display: none;
    position: fixed;
    top: 0; left: 0; width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.75);
    color: white;
    font-family: Arial, sans-serif;
    font-size: 48px;
    text-align: center;
    padding-top: 20vh;
    z-index: 20;
  }
  #gameOverOverlay {
    color: red;
  }

  #restartBtn, #levelRestartBtn {
    margin-top: 20px;
    font-size: 24px;
    cursor: pointer;
    padding: 10px 20px;
  }

  #progressBarContainer {
    position: fixed;
    top: 50px; left: 10px;
    width: 300px;
    height: 20px;
    background: #555;
    border-radius: 10px;
    overflow: hidden;
    z-index: 15;
  }
  #progressBarFill {
    width: 0%;
    height: 100%;
    background: #0f0;
    transition: width 0.3s ease;
  }
</style>
</head>
<body>

<div id="score">Score: 0</div>
<div id="progressBarContainer">
  <div id="progressBarFill"></div>
</div>
<div id="gameOverOverlay">
  Game Over!<br />
  <button id="restartBtn">Restart</button>
</div>
<div id="levelCompleteOverlay">
  Level Complete!<br />
  <button id="levelRestartBtn">Play Again</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
(() => {
  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.z = 30;

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lighting
  const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
  scene.add(ambientLight);

  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(10, 10, 10);
  scene.add(directionalLight);

  // Starfield
  const starsGeometry = new THREE.BufferGeometry();
  const starCount = 500;
  const starVertices = [];
  for (let i = 0; i < starCount; i++) {
    starVertices.push(
      (Math.random() - 0.5) * 200,
      (Math.random() - 0.5) * 200,
      (Math.random() - 0.5) * 200
    );
  }
  starsGeometry.setAttribute(
    'position',
    new THREE.Float32BufferAttribute(starVertices, 3)
  );
  const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff });
  const starField = new THREE.Points(starsGeometry, starsMaterial);
  scene.add(starField);

  // Player spaceship
  const ship = new THREE.Group();

  const coneGeometry = new THREE.ConeGeometry(1, 3, 8);
  const coneMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
  const cone = new THREE.Mesh(coneGeometry, coneMaterial);
  cone.rotation.x = Math.PI / 2;
  ship.add(cone);

  const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 3, 8);
  const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x007700 });
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  body.position.y = -1.5;
  ship.add(body);

  ship.position.set(0, 0, 20);
  scene.add(ship);

  // Movement controls
  const shipSpeed = 0.45;
  const shipBounds = { x: 15, y: 10, z: 20 };
  const keysPressed = {};

  window.addEventListener('keydown', (e) => {
    keysPressed[e.key.toLowerCase()] = true;
  });
  window.addEventListener('keyup', (e) => {
    keysPressed[e.key.toLowerCase()] = false;
  });

  function updateShip() {
    // Arrow keys control x and y
    if (keysPressed['arrowleft']) ship.position.x -= shipSpeed;
    if (keysPressed['arrowright']) ship.position.x += shipSpeed;
    if (keysPressed['arrowup']) ship.position.y += shipSpeed;
    if (keysPressed['arrowdown']) ship.position.y -= shipSpeed;

    // A and Z control forward/backward (z axis)
    if (keysPressed['a']) ship.position.z -= shipSpeed;
    if (keysPressed['z']) ship.position.z += shipSpeed;

    ship.position.x = THREE.MathUtils.clamp(ship.position.x, -shipBounds.x, shipBounds.x);
    ship.position.y = THREE.MathUtils.clamp(ship.position.y, -shipBounds.y, shipBounds.y);
    ship.position.z = THREE.MathUtils.clamp(ship.position.z, -shipBounds.z, shipBounds.z);
  }

  // Asteroids
  let asteroidCount = 30;
  const asteroids = [];

  function createAsteroid() {
    const geometry = new THREE.IcosahedronGeometry(1, 1);
    const material = new THREE.MeshStandardMaterial({ color: 0x666666, flatShading: true });
    const asteroid = new THREE.Mesh(geometry, material);
    asteroid.position.set(
      (Math.random() - 0.5) * 40,
      (Math.random() - 0.5) * 20,
      -50 - Math.random() * 100
    );
    asteroid.userData.velocity = new THREE.Vector3(
      (Math.random() - 0.5) * 0.1,
      (Math.random() - 0.5) * 0.05,
      0.2 + Math.random() * 0.3
    );
    scene.add(asteroid);
    return asteroid;
  }

  function spawnAsteroids() {
    asteroids.forEach(ast => scene.remove(ast));
    asteroids.length = 0;
    for (let i = 0; i < asteroidCount; i++) {
      asteroids.push(createAsteroid());
    }
  }

  // Energy orbs (smaller radius now)
  const orbs = [];
  const orbsToCollect = 10;

  function createOrb() {
    const geometry = new THREE.SphereGeometry(0.1, 16, 16);
    const material = new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1 });
    const orb = new THREE.Mesh(geometry, material);
    return orb;
  }

  function spawnOrbCluster(centerPos, count = 5) {
    orbs.forEach(orb => scene.remove(orb));
    orbs.length = 0;

    for (let i = 0; i < count; i++) {
      const offset = new THREE.Vector3(
        (Math.random() - 0.5) * 8,
        (Math.random() - 0.5) * 8,
        (Math.random() - 0.5) * 8
      );
      const orb = createOrb();
      orb.position.copy(centerPos).add(offset);
      orbs.push(orb);
      scene.add(orb);
    }
  }

  // Collision detection helper
  function sphereCollision(pos1, radius1, pos2, radius2) {
    return pos1.distanceTo(pos2) < radius1 + radius2;
  }

  // Orb collection effect
  function playOrbCollectEffect(orb) {
    const glowGeometry = new THREE.SphereGeometry(orb.scale.x * 3, 16, 16);
    const glowMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.7 });
    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
    glow.position.copy(orb.position);
    scene.add(glow);

    setTimeout(() => scene.remove(glow), 300);

    const audio = new Audio('https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg');
    audio.play();
  }

  // Game state
  let score = 0;
  let gameOver = false;

  // UI
  const scoreEl = document.getElementById('score');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const levelCompleteOverlay = document.getElementById('levelCompleteOverlay');
  const restartBtn = document.getElementById('restartBtn');
  const levelRestartBtn = document.getElementById('levelRestartBtn');
  const progressBarFill = document.getElementById('progressBarFill');

  function updateScoreDisplay() {
    scoreEl.textContent = `Score: ${score}`;
  }

  function updateProgressBar() {
    const percent = Math.min((score / (orbsToCollect * 10)) * 100, 100);
    progressBarFill.style.width = `${percent}%`;
  }

  function showGameOver() {
    gameOverOverlay.style.display = 'block';
  }

  function hideGameOver() {
    gameOverOverlay.style.display = 'none';
  }

  function showLevelComplete() {
    levelCompleteOverlay.style.display = 'block';
  }

  function hideLevelComplete() {
    levelCompleteOverlay.style.display = 'none';
  }

  // Asteroid update with speed scaling
  function updateAsteroids() {
    const speedMultiplier = 1 + score / 100;

    asteroids.forEach(ast => {
      ast.position.addScaledVector(ast.userData.velocity, speedMultiplier);

      if (ast.position.z > 30) {
        ast.position.set(
          (Math.random() - 0.5) * 40,
          (Math.random() - 0.5) * 20,
          -100 - Math.random() * 50
        );
        ast.userData.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.1 * speedMultiplier,
          (Math.random() - 0.5) * 0.05 * speedMultiplier,
          (0.2 + Math.random() * 0.3) * speedMultiplier
        );
      }
    });
  }

  // Orbs rotate for visibility
  function updateOrbs() {
    orbs.forEach(orb => {
      orb.rotation.y += 0.02;
    });
  }

  // Check collisions
  function checkCollisions() {
    const shipPos = ship.position;
    const shipRadius = 2;

    for (let ast of asteroids) {
      if (sphereCollision(shipPos, shipRadius, ast.position, 1)) {
        gameOver = true;
        showGameOver();
        break;
      }
    }

    if (gameOver) return;

    for (let orb of orbs) {
      if (sphereCollision(shipPos, shipRadius, orb.position, 0.1)) {
        score += 10;
        updateScoreDisplay();
        updateProgressBar();
        playOrbCollectEffect(orb);

        spawnOrbCluster(ship.position, orbsToCollect);
        break;
      }
    }

    if (score >= orbsToCollect * 10) {
      showLevelComplete();
      gameOver = true;

      setTimeout(() => {
        hideLevelComplete();
        resetGame();
      }, 3500);
    }
  }

  // Restart handlers
  restartBtn.addEventListener('click', () => {
    resetGame();
  });

  levelRestartBtn.addEventListener('click', () => {
    hideLevelComplete();
    resetGame();
  });

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  function animate() {
    if (!gameOver) {
      requestAnimationFrame(animate);
    }
    updateShip();
    updateAsteroids();
    updateOrbs();
    checkCollisions();
    renderer.render(scene, camera);
  }

  function resetGame() {
    score = 0;
    updateScoreDisplay();
    updateProgressBar();
    gameOver = false;
    hideGameOver();
    hideLevelComplete();

    ship.position.set(0, 0, 20);
    asteroidCount = 30;
    spawnAsteroids();
    spawnOrbCluster(ship.position, orbsToCollect);

    animate();
  }

  resetGame();
})();
</script>

</body>
</html>
```



## 10.7 Summary of the Chapter

This chapter demonstrated a full project pipeline:

* Story → "Orbital Escape" space navigation game.
* GDD breaking story into gameplay, controls, obstacles, collectibles, UI.
* Vibe coding prompts to generate modular Three.js features.
* Code examples showing scene setup, spaceship controls, obstacles, collectibles, collision detection, and UI.
* Integration into a playable 3D game prototype with debugging strategies.

This structured approach lets you harness AI coding assistance while maintaining design control.


## Review Questions

1. How does breaking the GDD into features improve vibe coding results?
2. What are effective ways to do collision detection in 3D Three.js games?
3. Why is it important to modularize game features when prompting AI?
4. How do you debug and test AI-generated game code systematically?
5. What considerations are important for player controls in 3D space navigation games?



## Exercises

1. Extend the "Orbital Escape" game by adding a fuel mechanic limiting ship movement.
2. Use vibe coding to add a new enemy spaceship that chases the player.
3. Modify the starfield to have twinkling stars using shader materials.
4. Create prompts to implement a level progression system with increasing asteroid counts.

