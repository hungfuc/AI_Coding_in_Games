

# Chapter 11: Building a Unity FPS Game from Vibe Coding



## 11.1 Game Story: Neon Outlaw

You are a skilled mercenary known as the **Neon Outlaw**, navigating a dystopian cyber-city under siege. Armed with a high-tech plasma rifle, your mission is to infiltrate enemy strongholds, eliminate hostile drones and cybernetic enemies, and retrieve valuable data caches. The environment is dynamic — neon-lit streets, destructible cover, and fast-paced combat define your experience.

**Core Themes:**

* Intense first-person shooting action
* Tactical movement and cover mechanics
* Variety of enemy AI with shooting and patrol behaviors
* Collection of ammo, health packs, and mission objectives



## 11.2 Game Design Document (GDD) for Neon Outlaw

| Section             | Details                                                                                                  |
| ------------------- | -------------------------------------------------------------------------------------------------------- |
| **Game Title**      | Neon Outlaw                                                                                              |
| **Genre**           | First-Person Shooter (FPS)                                                                               |
| **Platform**        | PC / Mac (Unity)                                                                                         |
| **Target Audience** | Players who enjoy action-packed FPS games with cyberpunk aesthetics                                      |
| **Core Gameplay**   | Player moves in 3D first-person view, shoots enemies, takes cover, collects pickups, completes missions. |
| **Controls**        | WASD to move, mouse to look and aim, left mouse button to shoot, spacebar to jump, Ctrl to crouch.       |
| **Objectives**      | Eliminate enemies, collect data caches, survive waves, progress through levels.                          |
| **Key Mechanics**   | FPS camera & movement, shooting & reload, enemy AI, health & ammo pickups, mission timers.               |
| **Visual Style**    | Cyberpunk neon city with dark urban environments and glowing effects.                                    |
| **Audio**           | Futuristic weapons sounds, ambient city noises, enemy alerts, UI feedback.                               |



## 11.3 Vibe Coding Approach: Step-by-Step Prompting

Using vibe coding, we break down the game features and ask an LLM to generate Unity C# scripts in steps:



#### Step 1: Generate FPS Player Controller with Mouse Look and WASD movement

**Prompt:**

> Create a Unity C# script for a first-person player controller. The player should move with WASD keys, look around using mouse movement, and be able to jump and crouch. Include smooth camera rotation.


#### Step 2: Implement shooting mechanics with raycasting and ammo management

**Prompt:**

> Generate a Unity C# script that allows the player to shoot a plasma rifle with left mouse button. Use raycasting to detect hits on enemies. Include ammo count, reloading, and shooting cooldown.


#### Step 3: Design enemy AI that patrols and shoots at the player

**Prompt:**

> Generate a Unity C# script for enemy drones that patrol between waypoints and shoot at the player if within range and line of sight. They should have health and be destroyed when health reaches zero.


#### Step 4: Create pickups: ammo packs and health kits

**Prompt:**

> Generate a Unity C# script for ammo and health pickups. When the player collides with these, increase ammo or health and play a pickup sound.



#### Step 5: Setup mission objectives and timer

**Prompt:**

> Generate a Unity C# script that tracks mission objectives such as collecting data caches, with a countdown timer. Display mission progress in UI.


#### Step 6: Build UI for health, ammo, crosshair, and mission status

**Prompt:**

> Generate Unity UI setup and scripts to display player health, ammo count, a crosshair in the center, and mission timer.



#### Step 7: Create Game Manager to handle game states, player death, and mission success/failure

**Prompt:**

> Generate a Unity Game Manager script that manages player health, mission states, game over conditions, and restarting the level.



## 11.4 Sample Code Examples Generated by Vibe Coding


#### FPS Player Controller (Step 1)
**FPSController.cs**
```csharp
using UnityEngine;

public class FPSController : MonoBehaviour
{
    public float walkSpeed = 6f;
    public float jumpForce = 7f;
    public float gravity = -9.81f;
    public Transform playerCamera;
    public float mouseSensitivity = 100f;
    public float crouchHeight = 1f;
    public float standingHeight = 2f;

    private CharacterController controller;
    private float xRotation = 0f;
    private Vector3 velocity;
    private bool isGrounded;
    private bool isCrouching = false;

    void Start()
    {
        controller = GetComponent<CharacterController>();
        Cursor.lockState = CursorLockMode.Locked;
    }

    void Update()
    {
        HandleMouseLook();
        HandleMovement();
    }

    void HandleMouseLook()
    {
        float mouseX = Input.GetAxis("Mouse X") * mouseSensitivity * Time.deltaTime;
        float mouseY = Input.GetAxis("Mouse Y") * mouseSensitivity * Time.deltaTime;

        xRotation -= mouseY;
        xRotation = Mathf.Clamp(xRotation, -90f, 90f);

        playerCamera.localRotation = Quaternion.Euler(xRotation, 0, 0);
        transform.Rotate(Vector3.up * mouseX);
    }

    void HandleMovement()
    {
        isGrounded = controller.isGrounded;

        if (isGrounded && velocity.y < 0)
        {
            velocity.y = -2f;
        }

        float x = Input.GetAxis("Horizontal");
        float z = Input.GetAxis("Vertical");

        Vector3 move = transform.right * x + transform.forward * z;
        controller.Move(move * walkSpeed * Time.deltaTime);

        if (Input.GetButtonDown("Jump") && isGrounded)
        {
            velocity.y = Mathf.Sqrt(jumpForce * -2f * gravity);
        }

        if (Input.GetKeyDown(KeyCode.LeftControl))
        {
            ToggleCrouch();
        }

        velocity.y += gravity * Time.deltaTime;
        controller.Move(velocity * Time.deltaTime);
    }

    void ToggleCrouch()
    {
        if (isCrouching)
        {
            controller.height = standingHeight;
            isCrouching = false;
        }
        else
        {
            controller.height = crouchHeight;
            isCrouching = true;
        }
    }
}
```

#### Shooting Mechanic (Step 2)
**PlayerShooting.cs**

```csharp
using UnityEngine;

public class PlayerShooting : MonoBehaviour
{
    public float damage = 25f;
    public float range = 100f;
    public float fireRate = 0.2f;
    public int maxAmmo = 30;
    public float reloadTime = 1.5f;

    public Camera fpsCam;
    public ParticleSystem muzzleFlash;
    public AudioSource gunShotSound;

    private int currentAmmo;
    private bool isReloading = false;
    private float nextTimeToFire = 0f;

    void Start()
    {
        currentAmmo = maxAmmo;
    }

    void Update()
    {
        if (isReloading)
            return;

        if (currentAmmo <= 0)
        {
            StartCoroutine(Reload());
            return;
        }

        if (Input.GetButton("Fire1") && Time.time >= nextTimeToFire)
        {
            nextTimeToFire = Time.time + fireRate;
            Shoot();
        }
    }

    IEnumerator Reload()
    {
        isReloading = true;
        // Play reload animation/sound here if available
        yield return new WaitForSeconds(reloadTime);
        currentAmmo = maxAmmo;
        isReloading = false;
    }

    void Shoot()
    {
        muzzleFlash.Play();
        gunShotSound.Play();
        currentAmmo--;

        RaycastHit hit;
        if (Physics.Raycast(fpsCam.transform.position, fpsCam.transform.forward, out hit, range))
        {
            EnemyHealth enemy = hit.transform.GetComponent<EnemyHealth>();
            if (enemy != null)
            {
                enemy.TakeDamage(damage);
            }
        }
    }

    public int GetCurrentAmmo()
    {
        return currentAmmo;
    }
}
```


#### Enemy AI (Step 3)

**EnemyAI.cs**

```csharp
using UnityEngine;
using UnityEngine.AI;

public class EnemyAI : MonoBehaviour
{
    public NavMeshAgent agent;
    public Transform[] patrolPoints;
    public float chaseRange = 15f;
    public float shootRange = 10f;
    public float fireRate = 1f;
    public float damage = 10f;

    private Transform player;
    private int currentPoint = 0;
    private float nextTimeToFire = 0f;
    private EnemyHealth health;

    void Start()
    {
        player = GameObject.FindGameObjectWithTag("Player").transform;
        health = GetComponent<EnemyHealth>();
        agent.SetDestination(patrolPoints[currentPoint].position);
    }

    void Update()
    {
        if (health.IsDead())
            return;

        float distance = Vector3.Distance(transform.position, player.position);

        if (distance < chaseRange)
        {
            agent.SetDestination(player.position);

            if (distance <= shootRange && Time.time >= nextTimeToFire)
            {
                ShootPlayer();
                nextTimeToFire = Time.time + 1f / fireRate;
            }
        }
        else
        {
            if (!agent.pathPending && agent.remainingDistance < 0.5f)
            {
                currentPoint = (currentPoint + 1) % patrolPoints.Length;
                agent.SetDestination(patrolPoints[currentPoint].position);
            }
        }
    }

    void ShootPlayer()
    {
        PlayerHealth playerHealth = player.GetComponent<PlayerHealth>();
        if (playerHealth != null)
        {
            playerHealth.TakeDamage(damage);
        }
        // Add shooting animation or effects here
    }
}
```



#### Health Pickup (Step 4)

**HealthPickup.cs**

```csharp
using UnityEngine;

public class HealthPickup : MonoBehaviour
{
    public int healAmount = 25;
    public AudioClip pickupSound;

    void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            PlayerHealth playerHealth = other.GetComponent<PlayerHealth>();
            if (playerHealth != null)
            {
                playerHealth.Heal(healAmount);
                AudioSource.PlayClipAtPoint(pickupSound, transform.position);
                Destroy(gameObject);
            }
        }
    }
}
```



#### Mission Timer (Step 5)
**MissionTimer.cs**
```csharp
using UnityEngine;
using UnityEngine.UI;

public class MissionTimer : MonoBehaviour
{
    public float missionDuration = 180f;
    public Text timerText;
    private float timeRemaining;
    private bool missionActive = true;

    void Start()
    {
        timeRemaining = missionDuration;
    }

    void Update()
    {
        if (!missionActive) return;

        timeRemaining -= Time.deltaTime;
        if (timeRemaining <= 0)
        {
            timeRemaining = 0;
            missionActive = false;
            GameManager.Instance.MissionFailed();
        }

        timerText.text = $"Time Left: {timeRemaining:F1}s";
    }
}
```


#### Game Manager (Step 7)

**GameManager**

```csharp
using UnityEngine;
using UnityEngine.SceneManagement;

public class GameManager : MonoBehaviour
{
    public static GameManager Instance;

    private int playerHealth = 100;
    private bool missionActive = true;

    void Awake()
    {
        if (Instance == null) Instance = this;
        else Destroy(gameObject);
    }

    public void MissionFailed()
    {
        missionActive = false;
        UIManager.Instance.ShowGameOver();
        // Additional failure logic here
    }

    public void PlayerDied()
    {
        missionActive = false;
        UIManager.Instance.ShowGameOver();
    }

    public void RestartLevel()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex);
    }
}
```



## 11.5 Neon Outlaw — Complete Unity FPS Project Blueprint

The following is a complete **Unity project blueprint** for **Neon Outlaw** FPS with all scripts, prefab descriptions, and setup instructions so you can open it directly or build on top.



#### 1. Project Setup

* Unity version: 2022.3 LTS or later recommended
* Create a new 3D Unity project
* Import **Standard Assets** for CharacterController (optional)
* Create folders:

  * Scripts
  * Prefabs
  * Materials
  * Audio
  * UI
  * Scenes



#### 2. Scene Setup

* Create a basic environment with:

  * Flat ground plane (add collider)
  * Walls or blocks for cover (primitive cubes)
  * Lighting with a directional light and some point lights (neon effect)
  * Add a NavMesh surface for enemy AI navigation (package: AI Navigation)
* Create empty GameObjects for:

  * Enemy spawn points (with waypoints for patrol)
  * Pickups spawn points (ammo, health)
  * Data cache mission objectives



#### 3. Core Prefabs & Components

| Prefab        | Description & Components                                                                                                                    |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------- |
| Player        | Capsule with **FPSController.cs**, **PlayerShooting.cs**, **CharacterController**, Camera child with **AudioListener**, **PlayerHealth.cs** |
| Enemy Drone   | Capsule or custom model with **EnemyAI.cs**, **EnemyHealth.cs**, **NavMeshAgent**, Collider                                                 |
| Ammo Pickup   | Small glowing object with **AmmoPickup.cs**, Collider (Trigger)                                                                             |
| Health Pickup | Glowing cross or sphere with **HealthPickup.cs**, Collider (Trigger)                                                                        |
| Data Cache    | Floating holographic object, Collider (Trigger), mission script                                                                             |
| UI Canvas     | HUD showing health bar, ammo count, crosshair, mission timer                                                                                |



#### 4. Complete Scripts

**FPSController.cs**

*(See section 11.4 above for full code)*

**PlayerShooting.cs**

*(See section 11.4 above for full code)*

**EnemyAI.cs**

*(See section 11.4 above for full code)*

**PlayerHealth.cs**

```csharp
using UnityEngine;

public class PlayerHealth : MonoBehaviour
{
    public int maxHealth = 100;
    private int currentHealth;

    void Start()
    {
        currentHealth = maxHealth;
        UIManager.Instance.UpdateHealth(currentHealth);
    }

    public void TakeDamage(int amount)
    {
        currentHealth -= amount;
        UIManager.Instance.UpdateHealth(currentHealth);

        if (currentHealth <= 0)
        {
            currentHealth = 0;
            Die();
        }
    }

    public void Heal(int amount)
    {
        currentHealth = Mathf.Min(currentHealth + amount, maxHealth);
        UIManager.Instance.UpdateHealth(currentHealth);
    }

    void Die()
    {
        GameManager.Instance.PlayerDied();
        // Play death animation, disable controls
    }
}
```

**EnemyHealth.cs**

```csharp
using UnityEngine;

public class EnemyHealth : MonoBehaviour
{
    public int maxHealth = 50;
    private int currentHealth;
    private bool isDead = false;

    void Start()
    {
        currentHealth = maxHealth;
    }

    public void TakeDamage(float amount)
    {
        if (isDead) return;

        currentHealth -= (int)amount;

        if (currentHealth <= 0)
        {
            Die();
        }
    }

    void Die()
    {
        isDead = true;
        // Play death animation
        Destroy(gameObject, 2f); // Delay to allow effects
    }

    public bool IsDead()
    {
        return isDead;
    }
}
```

#### AmmoPickup.cs

```csharp
using UnityEngine;

public class AmmoPickup : MonoBehaviour
{
    public int ammoAmount = 15;
    public AudioClip pickupSound;

    void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player"))
        {
            PlayerShooting shooting = other.GetComponent<PlayerShooting>();
            if (shooting != null)
            {
                shooting.AddAmmo(ammoAmount);
                AudioSource.PlayClipAtPoint(pickupSound, transform.position);
                Destroy(gameObject);
            }
        }
    }
}
```

#### UIManager.cs

```csharp
using UnityEngine;
using UnityEngine.UI;

public class UIManager : MonoBehaviour
{
    public static UIManager Instance;

    public Slider healthBar;
    public Text ammoText;
    public Text missionTimerText;
    public GameObject gameOverPanel;
    public Image crosshair;

    void Awake()
    {
        if (Instance == null) Instance = this;
        else Destroy(gameObject);
    }

    public void UpdateHealth(int currentHealth)
    {
        healthBar.value = currentHealth;
    }

    public void UpdateAmmo(int currentAmmo, int maxAmmo)
    {
        ammoText.text = $"{currentAmmo} / {maxAmmo}";
    }

    public void UpdateMissionTimer(float timeLeft)
    {
        missionTimerText.text = $"Time Left: {timeLeft:F1}s";
    }

    public void ShowGameOver()
    {
        gameOverPanel.SetActive(true);
        Cursor.lockState = CursorLockMode.None;
    }
}
```

#### Extensions to PlayerShooting.cs for Ammo Adding

Add this method inside PlayerShooting.cs:

```csharp
public void AddAmmo(int amount)
{
    currentAmmo = Mathf.Min(currentAmmo + amount, maxAmmo);
    UIManager.Instance.UpdateAmmo(currentAmmo, maxAmmo);
}
```



#### 5. Setting Up the Scene

1. Place the Player prefab with **FPSController**, **PlayerShooting**, and **PlayerHealth** scripts.
2. Create several enemy drones in the scene with patrol waypoints and **EnemyAI**, **EnemyHealth**.
3. Place ammo and health pickups at strategic points.
4. Add data cache objects as mission objectives.
5. Setup UI Canvas with **UIManager** components bound to UI elements.
6. Add a **GameManager** object to manage game state.
7. Configure the NavMesh for enemy navigation.
8. Tune lightings and add neon cyberpunk materials for atmosphere.



#### 6. Running and Testing

* Enter Play Mode to test FPS movement and shooting.
* Verify enemies patrol and attack properly.
* Pick up ammo and health to see UI update.
* Complete mission objectives before timer runs out.
* Use console and Debug.Log for troubleshooting.


#### 7. Expanding the Project

* Add weapon switching.
* Introduce more enemy types with different behaviors.
* Add destructible cover.
* Implement multiplayer networking.
* Polish UI and sound effects.




The included zip file bundles everything together.

- All C# scripts (FPSController, PlayerShooting, EnemyAI, Health and Ammo pickups, UIManager, GameManager, MissionTimer)
- README.txt with setup instructions
- Organized folder structure for easy import to Unity
- You can open this in Unity 2022.3 LTS or later and start running and extending the game right away.




## 11.6 Testing and Debugging the FPS Game

* Test smoothness of player movement and camera rotation in Unity Editor.
* Check shooting mechanics: ensure raycast hits register correctly on enemies.
* Verify enemy AI patrol and chase behavior; watch for bugs or stuck navigation.
* Confirm pickups update player health/ammo correctly.
* Use debug logs or gizmos to visualize patrol paths and raycasts.
* Test mission timer for proper countdown and failure handling.
* Use Unity’s Profiler to monitor performance during combat.



## 11.7 Summary of the Chapter

In this chapter, you learned to build a **cyberpunk FPS game** from scratch by:

* Defining a detailed game story with engaging gameplay themes.
* Creating a comprehensive game design document.
* Using **vibe coding** prompts to generate Unity scripts for core gameplay features.
* Combining those modules into a cohesive Unity FPS prototype.
* Applying best practices for debugging and testing complex systems.

This approach leverages AI-assisted coding to speed up iterative game development in Unity.

